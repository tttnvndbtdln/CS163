#include <iostream>
#include <cstring>
#include <cctype>

//Phuong Pham
//CS 163
//Program 4
//May 2016

//The purpose of this program is to build a "study guide" consisting of information about certain 
//topics in a certain class. Information along with the topic include the topic's title, a description
//that the user knows about the topic, the chapter number that the topic is located in the
//textbook, the starting page of the material, the ending page of the topic, and a flag to indicate
//whether further study is needed on the material. This study guide is entirely generated by the 
//user. That is, all information on this study guide must come from the user. The user may then 
//perform a number of actions about the study guide, including adding new topics to the study 
//guide, removing a topic from the study guide (along with all of its relevant information), edit
//the description of the study guide as the student progresses in his/her studying, retrieve 
//information about a certain topic (then display if the main application would like to do so),
//displaying all topics whose first letter is within a range of letters provided by the user
//(e.g. display all topics whose words' first letter are within the range of A through M), and
//displaying all topics in the study guide. 

//This program is implemented using a table abstract data type using a binary search tree as 
//the data structure to store the information about each topic in the study guide. This gives 
//us the advantage of a logarithmic algorithm for insert, remove, and retrieve, which are
//usually the operations for working with a study guide. It also provides us with the flexibility
//of displaying the data in sorted order and the ability to display the data in a range. 

//A struct is first used to store all of the information about the topic, including two pointers to
//point to the two children of the parent's node. A class is established with all of the operations
//the user can perform in its public sections and the root pointer to the tree is placed under the
//private section. Furthermore, in order to maintain the integrity of the data stored, no node
//pointers should exist (pass in to the functions from main) and so the functions in the public
//sections will simply call the private functions. The private functions are the ones that actually
//perform the operations recursively, since it needs to be passed in the node pointer to do so.  



//Struct to group together different inofrmation regarding a topic
struct node
{
	char * keyword;
	char * description;
	int chapter;
	int start_page; //Starting page of the material
	int end_page; //Ending page of the material
	char flag;
	node * left;
	node * right;
};



//Table ADT is managed by a class
class table
{
	public:
		table(); //Constructor
		~table(); //Destructor
		
		//Insert new topic into the study guide. All of the information is provided
		//by the main application. This function then calls its private counterpart so that 
		//that function can recursively calls itself with root -> left and root -> right.
		//INPUT: This function takes in 6 arguments, all of which are information listed
		//in the stuct. This includes a dynamically array of the keyword, array of
		//description, chapter number, starting page, ending page, and a flag to
		//indicates whether further study is needed.
		//OUTPUT: Returns success/failure state if item was added.
		int insert(char *, char *, int, int, int, char);
		
		//Remove an item from the study guide. It takes in the keyword or topic
		//that the user wants to remove. This function calls its private counterpart so
		//that that funciton can recursively calls itself with root -> left and root -> right.
		//INPUT: The funciton takes in the keyword or topic that the usert wants to remove.
		//OUPUT: Return success/failure state if item was removed.
		int remove(char * key_word);
		
		//Edit the description of an item in the study guide. It takes in the keyword that the
		//user wants to modify the description of, as well as the next part of the 
		//description that the user wants to add on (concatenate). This function calls its
		//private counterpart so the function can recursively calls itself with root -> left or
		//root -> right.
		//INPUT: The function takes in the keyword/topic that the user wants to modify
		//and the new part of the description to add.
		//OUTPUT: Return success/failure state to calling routine.
		int edit(char * key_word, char * topic_description);
		
		//Retrieve information about a certain topic. An instance of the struct is created. 
		//Then through passing in by reference along with the keyword/topic that the user
		//would like the information of, the passed in struct's data members are copied. This
		//function also calls its recursive private counterpart in order to use the root pointer.
		//INPUT: The function takes in the keyword/topic desired and the struct to store 
		//the information if found in the tree.
		//OUTPUT: Return success/failure state if item was found or not.
		int retrieve(node & found, char * key_word);
		
		//Display all keyword/topic that start with a certain letter in a range of letters. The 
		//range is provided by the main application.
		//INPUT: The function takes in the letter that starts the range and the letter that 
		//ends it.
		//OUTPUT: Display all topics whose letters are within the range, if any.
		void display_range(char start_range, char end_range);
		
		//Display all keywords in the study guide.
		//INPUT: Function takes in no argument.
		//OUPUT: Display all topics in the study guide, if any.
		void display_all();
		
	private:
		node * root; //Root pointer
		
		//This function is called by the destructor (its private recursive counterpart) to 
		//recursively calls the function itself and delete every nodes in the tree.
		//INPUT: Function takes in the root pointer of the tree.
		//OUTPUT: No output.
		void destroy(node * & root);
		
		//Private insert function. Takes in all of the information passed by the public insert
		//function as well as the pointer or next pointer. This recursive calls ensure traversal
		//to a leaf in order to add the new topic.
		//INPUT: This function takes in 6 arguments, all of which are information listed
		//in the stuct. This includes a dynamically array of the keyword, array of
		//description, chapter number, starting page, ending page, and a flag to
		//indicates whether further study is needed. It also takes in the node pointer.
		//OUTPUT: Return success/failure state back to the public insert function. 
		int insert(node * & root, char *, char *, int, int, int, char);
		
		//Private remove function. Takes in the topic keyword passed in by the public remove
		//function and the pointer. This function ensures every special case of removal is covered 
		//and to remove the appropriate node.
		//INPUT: Keyword passed in by public remove function and the root pointer.
		//OUTPUT: Return success/failure state back to public remove function.
		int remove(node * & root, char * key_word);
		
		//Private edit function. Takes in the keyword and the description to be added from the
		//public counterpart. It also takes in the node pointer in order to recursively calls itself.
		//INPUT: Function takes in topic and the description to be concatenate to the current
		//description. It also takes in the node pointer.
		//OUPUT: Return success/failure back to the public edit function.
		int edit(node * root, char * key_word, char * topic_description);
		
		//Private retrieve function. Takes in the keyword and the struct in order to store 
		//the information once the keyword is found. It also takes the node pointer.
		//INPUT. Node pointer, the struct passed in by reference, and the keyword/topic 
		//to be located in the tree.
		//OUTPUT. Return success/failure state back to the public counterpart.
		int retrieve(node * root, node & found, char * key_word);
		
		//Private display range function. Takes in the two characters representing the starting
		//and ending of the range, respectively, as well as the node pointer.
		//INPUT: Starting and ending characters of the desired range, respectively, and the node
		//pointer.
		//OUTPUT: Display all topics whose letters are in that range, if any. 
		void display_range(node * root, char, char);
		
		//Private display all function. Takes in the node pointer to traverse the tree and display
		//all nodes keyword data members.
		//INPUT: Pointer to the root of tree.
		//OUTPUT: All keywords of the nodes in the tree, if any.
		void display_all(node * root);
};